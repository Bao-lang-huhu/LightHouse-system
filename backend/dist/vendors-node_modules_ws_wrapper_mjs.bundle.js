"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_ws_wrapper_mjs";
exports.ids = ["vendors-node_modules_ws_wrapper_mjs"];
exports.modules = {

/***/ "../node_modules/ws/lib/buffer-util.js":
/*!*********************************************!*\
  !*** ../node_modules/ws/lib/buffer-util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\n/**\r\n * Merges an array of buffers into a new buffer.\r\n *\r\n * @param {Buffer[]} list The array of buffers to concat\r\n * @param {Number} totalLength The total length of buffers in the list\r\n * @return {Buffer} The resulting buffer\r\n * @public\r\n */\r\nfunction concat(list, totalLength) {\r\n  if (list.length === 0) return EMPTY_BUFFER;\r\n  if (list.length === 1) return list[0];\r\n\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  let offset = 0;\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    target.set(buf, offset);\r\n    offset += buf.length;\r\n  }\r\n\r\n  if (offset < totalLength) {\r\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Masks a buffer using the given mask.\r\n *\r\n * @param {Buffer} source The buffer to mask\r\n * @param {Buffer} mask The mask to use\r\n * @param {Buffer} output The buffer where to store the result\r\n * @param {Number} offset The offset at which to start writing\r\n * @param {Number} length The number of bytes to mask.\r\n * @public\r\n */\r\nfunction _mask(source, mask, output, offset, length) {\r\n  for (let i = 0; i < length; i++) {\r\n    output[offset + i] = source[i] ^ mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Unmasks a buffer using the given mask.\r\n *\r\n * @param {Buffer} buffer The buffer to unmask\r\n * @param {Buffer} mask The mask to use\r\n * @public\r\n */\r\nfunction _unmask(buffer, mask) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    buffer[i] ^= mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} buf The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n * @public\r\n */\r\nfunction toArrayBuffer(buf) {\r\n  if (buf.length === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n}\r\n\r\n/**\r\n * Converts `data` to a `Buffer`.\r\n *\r\n * @param {*} data The data to convert\r\n * @return {Buffer} The buffer\r\n * @throws {TypeError}\r\n * @public\r\n */\r\nfunction toBuffer(data) {\r\n  toBuffer.readOnly = true;\r\n\r\n  if (Buffer.isBuffer(data)) return data;\r\n\r\n  let buf;\r\n\r\n  if (data instanceof ArrayBuffer) {\r\n    buf = new FastBuffer(data);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\r\n  } else {\r\n    buf = Buffer.from(data);\r\n    toBuffer.readOnly = false;\r\n  }\r\n\r\n  return buf;\r\n}\r\n\r\nmodule.exports = {\r\n  concat,\r\n  mask: _mask,\r\n  toArrayBuffer,\r\n  toBuffer,\r\n  unmask: _unmask\r\n};\r\n\r\n/* istanbul ignore else  */\r\nif (!process.env.WS_NO_BUFFER_UTIL) {\r\n  try {\r\n    const bufferUtil = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\n\r\n    module.exports.mask = function (source, mask, output, offset, length) {\r\n      if (length < 48) _mask(source, mask, output, offset, length);\r\n      else bufferUtil.mask(source, mask, output, offset, length);\r\n    };\r\n\r\n    module.exports.unmask = function (buffer, mask) {\r\n      if (buffer.length < 32) _unmask(buffer, mask);\r\n      else bufferUtil.unmask(buffer, mask);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "../node_modules/ws/lib/constants.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/constants.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\r\n\r\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\r\nconst hasBlob = typeof Blob !== 'undefined';\r\n\r\nif (hasBlob) BINARY_TYPES.push('blob');\r\n\r\nmodule.exports = {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER: Buffer.alloc(0),\r\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\r\n  hasBlob,\r\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\r\n  kListener: Symbol('kListener'),\r\n  kStatusCode: Symbol('status-code'),\r\n  kWebSocket: Symbol('websocket'),\r\n  NOOP: () => {}\r\n};\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "../node_modules/ws/lib/event-target.js":
/*!**********************************************!*\
  !*** ../node_modules/ws/lib/event-target.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\n\r\nconst kCode = Symbol('kCode');\r\nconst kData = Symbol('kData');\r\nconst kError = Symbol('kError');\r\nconst kMessage = Symbol('kMessage');\r\nconst kReason = Symbol('kReason');\r\nconst kTarget = Symbol('kTarget');\r\nconst kType = Symbol('kType');\r\nconst kWasClean = Symbol('kWasClean');\r\n\r\n/**\r\n * Class representing an event.\r\n */\r\nclass Event {\r\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @throws {TypeError} If the `type` argument is not specified\r\n   */\r\n  constructor(type) {\r\n    this[kTarget] = null;\r\n    this[kType] = type;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get target() {\r\n    return this[kTarget];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get type() {\r\n    return this[kType];\r\n  }\r\n}\r\n\r\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\r\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\r\n\r\n/**\r\n * Class representing a close event.\r\n *\r\n * @extends Event\r\n */\r\nclass CloseEvent extends Event {\r\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {Number} [options.code=0] The status code explaining why the\r\n   *     connection was closed\r\n   * @param {String} [options.reason=''] A human-readable string explaining why\r\n   *     the connection was closed\r\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\r\n   *     connection was cleanly closed\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kCode] = options.code === undefined ? 0 : options.code;\r\n    this[kReason] = options.reason === undefined ? '' : options.reason;\r\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get code() {\r\n    return this[kCode];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get reason() {\r\n    return this[kReason];\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get wasClean() {\r\n    return this[kWasClean];\r\n  }\r\n}\r\n\r\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\r\n\r\n/**\r\n * Class representing an error event.\r\n *\r\n * @extends Event\r\n */\r\nclass ErrorEvent extends Event {\r\n  /**\r\n   * Create a new `ErrorEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.error=null] The error that generated this event\r\n   * @param {String} [options.message=''] The error message\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kError] = options.error === undefined ? null : options.error;\r\n    this[kMessage] = options.message === undefined ? '' : options.message;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get error() {\r\n    return this[kError];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get message() {\r\n    return this[kMessage];\r\n  }\r\n}\r\n\r\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\r\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\r\n\r\n/**\r\n * Class representing a message event.\r\n *\r\n * @extends Event\r\n */\r\nclass MessageEvent extends Event {\r\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.data=null] The message content\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kData] = options.data === undefined ? null : options.data;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get data() {\r\n    return this[kData];\r\n  }\r\n}\r\n\r\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\r\n\r\n/**\r\n * This provides methods for emulating the `EventTarget` interface. It's not\r\n * meant to be used directly.\r\n *\r\n * @mixin\r\n */\r\nconst EventTarget = {\r\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to listen for\r\n   * @param {(Function|Object)} handler The listener to add\r\n   * @param {Object} [options] An options object specifies characteristics about\r\n   *     the event listener\r\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\r\n   *     listener should be invoked at most once after being added. If `true`,\r\n   *     the listener would be automatically removed when invoked.\r\n   * @public\r\n   */\r\n  addEventListener(type, handler, options = {}) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (\r\n        !options[kForOnEventAttribute] &&\r\n        listener[kListener] === handler &&\r\n        !listener[kForOnEventAttribute]\r\n      ) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    let wrapper;\r\n\r\n    if (type === 'message') {\r\n      wrapper = function onMessage(data, isBinary) {\r\n        const event = new MessageEvent('message', {\r\n          data: isBinary ? data : data.toString()\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'close') {\r\n      wrapper = function onClose(code, message) {\r\n        const event = new CloseEvent('close', {\r\n          code,\r\n          reason: message.toString(),\r\n          wasClean: this._closeFrameReceived && this._closeFrameSent\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'error') {\r\n      wrapper = function onError(error) {\r\n        const event = new ErrorEvent('error', {\r\n          error,\r\n          message: error.message\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'open') {\r\n      wrapper = function onOpen() {\r\n        const event = new Event('open');\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\r\n    wrapper[kListener] = handler;\r\n\r\n    if (options.once) {\r\n      this.once(type, wrapper);\r\n    } else {\r\n      this.on(type, wrapper);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to remove\r\n   * @param {(Function|Object)} handler The listener to remove\r\n   * @public\r\n   */\r\n  removeEventListener(type, handler) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\r\n        this.removeListener(type, listener);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  CloseEvent,\r\n  ErrorEvent,\r\n  Event,\r\n  EventTarget,\r\n  MessageEvent\r\n};\r\n\r\n/**\r\n * Call an event listener\r\n *\r\n * @param {(Function|Object)} listener The listener to call\r\n * @param {*} thisArg The value to use as `this`` when calling the listener\r\n * @param {Event} event The event to pass to the listener\r\n * @private\r\n */\r\nfunction callListener(listener, thisArg, event) {\r\n  if (typeof listener === 'object' && listener.handleEvent) {\r\n    listener.handleEvent.call(listener, event);\r\n  } else {\r\n    listener.call(thisArg, event);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "../node_modules/ws/lib/extension.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/extension.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Adds an offer to the map of extension offers or a parameter to the map of\r\n * parameters.\r\n *\r\n * @param {Object} dest The map of extension offers or parameters\r\n * @param {String} name The extension or parameter name\r\n * @param {(Object|Boolean|String)} elem The extension parameters or the\r\n *     parameter value\r\n * @private\r\n */\r\nfunction push(dest, name, elem) {\r\n  if (dest[name] === undefined) dest[name] = [elem];\r\n  else dest[name].push(elem);\r\n}\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Extensions` header into an object.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Object} The parsed object\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const offers = Object.create(null);\r\n  let params = Object.create(null);\r\n  let mustUnescape = false;\r\n  let isEscaping = false;\r\n  let inQuotes = false;\r\n  let extensionName;\r\n  let paramName;\r\n  let start = -1;\r\n  let code = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (; i < header.length; i++) {\r\n    code = header.charCodeAt(i);\r\n\r\n    if (extensionName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (\r\n        i !== 0 &&\r\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n      ) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        const name = header.slice(start, end);\r\n        if (code === 0x2c) {\r\n          push(offers, name, params);\r\n          params = Object.create(null);\r\n        } else {\r\n          extensionName = name;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else if (paramName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (code === 0x20 || code === 0x09) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        push(params, header.slice(start, end), true);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\r\n        paramName = header.slice(start, i);\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else {\r\n      //\r\n      // The value of a quoted-string after unescaping must conform to the\r\n      // token ABNF, so only token characters are valid.\r\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\r\n      //\r\n      if (isEscaping) {\r\n        if (tokenChars[code] !== 1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (start === -1) start = i;\r\n        else if (!mustUnescape) mustUnescape = true;\r\n        isEscaping = false;\r\n      } else if (inQuotes) {\r\n        if (tokenChars[code] === 1) {\r\n          if (start === -1) start = i;\r\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\r\n          inQuotes = false;\r\n          end = i;\r\n        } else if (code === 0x5c /* '\\' */) {\r\n          isEscaping = true;\r\n        } else {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\r\n        inQuotes = true;\r\n      } else if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\r\n        if (end === -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        let value = header.slice(start, end);\r\n        if (mustUnescape) {\r\n          value = value.replace(/\\\\/g, '');\r\n          mustUnescape = false;\r\n        }\r\n        push(params, paramName, value);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        paramName = undefined;\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  if (end === -1) end = i;\r\n  const token = header.slice(start, end);\r\n  if (extensionName === undefined) {\r\n    push(offers, token, params);\r\n  } else {\r\n    if (paramName === undefined) {\r\n      push(params, token, true);\r\n    } else if (mustUnescape) {\r\n      push(params, paramName, token.replace(/\\\\/g, ''));\r\n    } else {\r\n      push(params, paramName, token);\r\n    }\r\n    push(offers, extensionName, params);\r\n  }\r\n\r\n  return offers;\r\n}\r\n\r\n/**\r\n * Builds the `Sec-WebSocket-Extensions` header field value.\r\n *\r\n * @param {Object} extensions The map of extensions and parameters to format\r\n * @return {String} A string representing the given object\r\n * @public\r\n */\r\nfunction format(extensions) {\r\n  return Object.keys(extensions)\r\n    .map((extension) => {\r\n      let configurations = extensions[extension];\r\n      if (!Array.isArray(configurations)) configurations = [configurations];\r\n      return configurations\r\n        .map((params) => {\r\n          return [extension]\r\n            .concat(\r\n              Object.keys(params).map((k) => {\r\n                let values = params[k];\r\n                if (!Array.isArray(values)) values = [values];\r\n                return values\r\n                  .map((v) => (v === true ? k : `${k}=${v}`))\r\n                  .join('; ');\r\n              })\r\n            )\r\n            .join('; ');\r\n        })\r\n        .join(', ');\r\n    })\r\n    .join(', ');\r\n}\r\n\r\nmodule.exports = { format, parse };\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "../node_modules/ws/lib/limiter.js":
/*!*****************************************!*\
  !*** ../node_modules/ws/lib/limiter.js ***!
  \*****************************************/
/***/ ((module) => {

eval("\r\n\r\nconst kDone = Symbol('kDone');\r\nconst kRun = Symbol('kRun');\r\n\r\n/**\r\n * A very simple job queue with adjustable concurrency. Adapted from\r\n * https://github.com/STRML/async-limiter\r\n */\r\nclass Limiter {\r\n  /**\r\n   * Creates a new `Limiter`.\r\n   *\r\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\r\n   *     to run concurrently\r\n   */\r\n  constructor(concurrency) {\r\n    this[kDone] = () => {\r\n      this.pending--;\r\n      this[kRun]();\r\n    };\r\n    this.concurrency = concurrency || Infinity;\r\n    this.jobs = [];\r\n    this.pending = 0;\r\n  }\r\n\r\n  /**\r\n   * Adds a job to the queue.\r\n   *\r\n   * @param {Function} job The job to run\r\n   * @public\r\n   */\r\n  add(job) {\r\n    this.jobs.push(job);\r\n    this[kRun]();\r\n  }\r\n\r\n  /**\r\n   * Removes a job from the queue and runs it if possible.\r\n   *\r\n   * @private\r\n   */\r\n  [kRun]() {\r\n    if (this.pending === this.concurrency) return;\r\n\r\n    if (this.jobs.length) {\r\n      const job = this.jobs.shift();\r\n\r\n      this.pending++;\r\n      job(this[kDone]);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Limiter;\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/limiter.js?");

/***/ }),

/***/ "../node_modules/ws/lib/permessage-deflate.js":
/*!****************************************************!*\
  !*** ../node_modules/ws/lib/permessage-deflate.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\n\r\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\r\nconst Limiter = __webpack_require__(/*! ./limiter */ \"../node_modules/ws/lib/limiter.js\");\r\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\r\nconst kPerMessageDeflate = Symbol('permessage-deflate');\r\nconst kTotalLength = Symbol('total-length');\r\nconst kCallback = Symbol('callback');\r\nconst kBuffers = Symbol('buffers');\r\nconst kError = Symbol('error');\r\n\r\n//\r\n// We limit zlib concurrency, which prevents severe memory fragmentation\r\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\r\n// and https://github.com/websockets/ws/issues/1202\r\n//\r\n// Intentionally global; it's the global thread pool that's an issue.\r\n//\r\nlet zlibLimiter;\r\n\r\n/**\r\n * permessage-deflate implementation.\r\n */\r\nclass PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} [options] Configuration options\r\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\r\n   *     acknowledge disabling of client context takeover\r\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\r\n   *     calls to zlib\r\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\r\n   *     disabling of server context takeover\r\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\r\n   *     messages should not be compressed if context takeover is disabled\r\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\r\n   *     deflate\r\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\r\n   *     inflate\r\n   * @param {Boolean} [isServer=false] Create the instance in either server or\r\n   *     client mode\r\n   * @param {Number} [maxPayload=0] The maximum allowed message length\r\n   */\r\n  constructor(options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold =\r\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n\r\n    this.params = null;\r\n\r\n    if (!zlibLimiter) {\r\n      const concurrency =\r\n        this._options.concurrencyLimit !== undefined\r\n          ? this._options.concurrencyLimit\r\n          : 10;\r\n      zlibLimiter = new Limiter(concurrency);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName() {\r\n    return 'permessage-deflate';\r\n  }\r\n\r\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer() {\r\n    const params = {};\r\n\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept(configurations) {\r\n    configurations = this.normalizeParams(configurations);\r\n\r\n    this.params = this._isServer\r\n      ? this.acceptAsServer(configurations)\r\n      : this.acceptAsClient(configurations);\r\n\r\n    return this.params;\r\n  }\r\n\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup() {\r\n    if (this._inflate) {\r\n      this._inflate.close();\r\n      this._inflate = null;\r\n    }\r\n\r\n    if (this._deflate) {\r\n      const callback = this._deflate[kCallback];\r\n\r\n      this._deflate.close();\r\n      this._deflate = null;\r\n\r\n      if (callback) {\r\n        callback(\r\n          new Error(\r\n            'The deflate stream was closed while data was being processed'\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer(offers) {\r\n    const opts = this._options;\r\n    const accepted = offers.find((params) => {\r\n      if (\r\n        (opts.serverNoContextTakeover === false &&\r\n          params.server_no_context_takeover) ||\r\n        (params.server_max_window_bits &&\r\n          (opts.serverMaxWindowBits === false ||\r\n            (typeof opts.serverMaxWindowBits === 'number' &&\r\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\r\n        (typeof opts.clientMaxWindowBits === 'number' &&\r\n          !params.client_max_window_bits)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    if (!accepted) {\r\n      throw new Error('None of the extension offers can be accepted');\r\n    }\r\n\r\n    if (opts.serverNoContextTakeover) {\r\n      accepted.server_no_context_takeover = true;\r\n    }\r\n    if (opts.clientNoContextTakeover) {\r\n      accepted.client_no_context_takeover = true;\r\n    }\r\n    if (typeof opts.serverMaxWindowBits === 'number') {\r\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\r\n    }\r\n    if (typeof opts.clientMaxWindowBits === 'number') {\r\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\r\n    } else if (\r\n      accepted.client_max_window_bits === true ||\r\n      opts.clientMaxWindowBits === false\r\n    ) {\r\n      delete accepted.client_max_window_bits;\r\n    }\r\n\r\n    return accepted;\r\n  }\r\n\r\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient(response) {\r\n    const params = response[0];\r\n\r\n    if (\r\n      this._options.clientNoContextTakeover === false &&\r\n      params.client_no_context_takeover\r\n    ) {\r\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\r\n    }\r\n\r\n    if (!params.client_max_window_bits) {\r\n      if (typeof this._options.clientMaxWindowBits === 'number') {\r\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      }\r\n    } else if (\r\n      this._options.clientMaxWindowBits === false ||\r\n      (typeof this._options.clientMaxWindowBits === 'number' &&\r\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\r\n    ) {\r\n      throw new Error(\r\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\r\n      );\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\r\n  normalizeParams(configurations) {\r\n    configurations.forEach((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        let value = params[key];\r\n\r\n        if (value.length > 1) {\r\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\r\n        }\r\n\r\n        value = value[0];\r\n\r\n        if (key === 'client_max_window_bits') {\r\n          if (value !== true) {\r\n            const num = +value;\r\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n              throw new TypeError(\r\n                `Invalid value for parameter \"${key}\": ${value}`\r\n              );\r\n            }\r\n            value = num;\r\n          } else if (!this._isServer) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else if (key === 'server_max_window_bits') {\r\n          const num = +value;\r\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n          value = num;\r\n        } else if (\r\n          key === 'client_no_context_takeover' ||\r\n          key === 'server_no_context_takeover'\r\n        ) {\r\n          if (value !== true) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else {\r\n          throw new Error(`Unknown parameter \"${key}\"`);\r\n        }\r\n\r\n        params[key] = value;\r\n      });\r\n    });\r\n\r\n    return configurations;\r\n  }\r\n\r\n  /**\r\n   * Decompress data. Concurrency limited.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data. Concurrency limited.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'client' : 'server';\r\n\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._inflate = zlib.createInflateRaw({\r\n        ...this._options.zlibInflateOptions,\r\n        windowBits\r\n      });\r\n      this._inflate[kPerMessageDeflate] = this;\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate.on('error', inflateOnError);\r\n      this._inflate.on('data', inflateOnData);\r\n    }\r\n\r\n    this._inflate[kCallback] = callback;\r\n\r\n    this._inflate.write(data);\r\n    if (fin) this._inflate.write(TRAILER);\r\n\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError];\r\n\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const data = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n\r\n      if (this._inflate._readableState.endEmitted) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n\r\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n          this._inflate.reset();\r\n        }\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'server' : 'client';\r\n\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._deflate = zlib.createDeflateRaw({\r\n        ...this._options.zlibDeflateOptions,\r\n        windowBits\r\n      });\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      this._deflate.on('data', deflateOnData);\r\n    }\r\n\r\n    this._deflate[kCallback] = callback;\r\n\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      if (!this._deflate) {\r\n        //\r\n        // The deflate stream was closed while data was being processed.\r\n        //\r\n        return;\r\n      }\r\n\r\n      let data = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n\r\n      if (fin) {\r\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\r\n      }\r\n\r\n      //\r\n      // Ensure that the callback will not be called again in\r\n      // `PerMessageDeflate#cleanup()`.\r\n      //\r\n      this._deflate[kCallback] = null;\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n        this._deflate.reset();\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PerMessageDeflate;\r\n\r\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction deflateOnData(chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction inflateOnData(chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n\r\n  if (\r\n    this[kPerMessageDeflate]._maxPayload < 1 ||\r\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\r\n  ) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n\r\n  this[kError] = new RangeError('Max payload size exceeded');\r\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\r\n  this[kError][kStatusCode] = 1009;\r\n  this.removeListener('data', inflateOnData);\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\r\nfunction inflateOnError(err) {\r\n  //\r\n  // There is no need to call `Zlib#close()` as the handle is automatically\r\n  // closed when an error is emitted.\r\n  //\r\n  this[kPerMessageDeflate]._inflate = null;\r\n  err[kStatusCode] = 1007;\r\n  this[kCallback](err);\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "../node_modules/ws/lib/receiver.js":
/*!******************************************!*\
  !*** ../node_modules/ws/lib/receiver.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  kStatusCode,\r\n  kWebSocket\r\n} = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\r\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\nconst DEFER_EVENT = 6;\r\n\r\n/**\r\n * HyBi Receiver implementation.\r\n *\r\n * @extends Writable\r\n */\r\nclass Receiver extends Writable {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\r\n   * @param {Object} [options.extensions] An object containing the negotiated\r\n   *     extensions\r\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\r\n   *     client or server mode\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n\r\n    this._allowSynchronousEvents =\r\n      options.allowSynchronousEvents !== undefined\r\n        ? options.allowSynchronousEvents\r\n        : true;\r\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\r\n    this._extensions = options.extensions || {};\r\n    this._isServer = !!options.isServer;\r\n    this._maxPayload = options.maxPayload | 0;\r\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\r\n    this[kWebSocket] = undefined;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._mask = undefined;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._opcode = 0;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n\r\n    this._errored = false;\r\n    this._loop = false;\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  _write(chunk, encoding, cb) {\r\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\r\n\r\n    this._bufferedBytes += chunk.length;\r\n    this._buffers.push(chunk);\r\n    this.startLoop(cb);\r\n  }\r\n\r\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\r\n  consume(n) {\r\n    this._bufferedBytes -= n;\r\n\r\n    if (n === this._buffers[0].length) return this._buffers.shift();\r\n\r\n    if (n < this._buffers[0].length) {\r\n      const buf = this._buffers[0];\r\n      this._buffers[0] = new FastBuffer(\r\n        buf.buffer,\r\n        buf.byteOffset + n,\r\n        buf.length - n\r\n      );\r\n\r\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\r\n    }\r\n\r\n    const dst = Buffer.allocUnsafe(n);\r\n\r\n    do {\r\n      const buf = this._buffers[0];\r\n      const offset = dst.length - n;\r\n\r\n      if (n >= buf.length) {\r\n        dst.set(this._buffers.shift(), offset);\r\n      } else {\r\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\r\n        this._buffers[0] = new FastBuffer(\r\n          buf.buffer,\r\n          buf.byteOffset + n,\r\n          buf.length - n\r\n        );\r\n      }\r\n\r\n      n -= buf.length;\r\n    } while (n > 0);\r\n\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  startLoop(cb) {\r\n    this._loop = true;\r\n\r\n    do {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          this.getInfo(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          this.getPayloadLength16(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          this.getPayloadLength64(cb);\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          this.getData(cb);\r\n          break;\r\n        case INFLATING:\r\n        case DEFER_EVENT:\r\n          this._loop = false;\r\n          return;\r\n      }\r\n    } while (this._loop);\r\n\r\n    if (!this._errored) cb();\r\n  }\r\n\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getInfo(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(2);\r\n\r\n    if ((buf[0] & 0x30) !== 0x00) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV2 and RSV3 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_2_3'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    const compressed = (buf[0] & 0x40) === 0x40;\r\n\r\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV1 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_1'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._fin = (buf[0] & 0x80) === 0x80;\r\n    this._opcode = buf[0] & 0x0f;\r\n    this._payloadLength = buf[1] & 0x7f;\r\n\r\n    if (this._opcode === 0x00) {\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (!this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'invalid opcode 0',\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._opcode = this._fragmented;\r\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\r\n      if (this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid opcode ${this._opcode}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\r\n      if (!this._fin) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'FIN must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_FIN'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        this._payloadLength > 0x7d ||\r\n        (this._opcode === 0x08 && this._payloadLength === 1)\r\n      ) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid payload length ${this._payloadLength}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else {\r\n      const error = this.createError(\r\n        RangeError,\r\n        `invalid opcode ${this._opcode}`,\r\n        true,\r\n        1002,\r\n        'WS_ERR_INVALID_OPCODE'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\r\n    this._masked = (buf[1] & 0x80) === 0x80;\r\n\r\n    if (this._isServer) {\r\n      if (!this._masked) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'MASK must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_MASK'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else if (this._masked) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'MASK must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_MASK'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\r\n    else this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength16(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = this.consume(2).readUInt16BE(0);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength64(cb) {\r\n    if (this._bufferedBytes < 8) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(8);\r\n    const num = buf.readUInt32BE(0);\r\n\r\n    //\r\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\r\n    // if payload length is greater than this number.\r\n    //\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\r\n        false,\r\n        1009,\r\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  haveLength(cb) {\r\n    if (this._payloadLength && this._opcode < 0x08) {\r\n      this._totalPayloadLength += this._payloadLength;\r\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'Max payload size exceeded',\r\n          false,\r\n          1009,\r\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (this._masked) this._state = GET_MASK;\r\n    else this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask() {\r\n    if (this._bufferedBytes < 4) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._mask = this.consume(4);\r\n    this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getData(cb) {\r\n    let data = EMPTY_BUFFER;\r\n\r\n    if (this._payloadLength) {\r\n      if (this._bufferedBytes < this._payloadLength) {\r\n        this._loop = false;\r\n        return;\r\n      }\r\n\r\n      data = this.consume(this._payloadLength);\r\n\r\n      if (\r\n        this._masked &&\r\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\r\n      ) {\r\n        unmask(data, this._mask);\r\n      }\r\n    }\r\n\r\n    if (this._opcode > 0x07) {\r\n      this.controlMessage(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (data.length) {\r\n      //\r\n      // This message is not compressed so its length is the sum of the payload\r\n      // length of all fragments.\r\n      //\r\n      this._messageLength = this._totalPayloadLength;\r\n      this._fragments.push(data);\r\n    }\r\n\r\n    this.dataMessage(cb);\r\n  }\r\n\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  decompress(data, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err) return cb(err);\r\n\r\n      if (buf.length) {\r\n        this._messageLength += buf.length;\r\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            'Max payload size exceeded',\r\n            false,\r\n            1009,\r\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._fragments.push(buf);\r\n      }\r\n\r\n      this.dataMessage(cb);\r\n      if (this._state === GET_INFO) this.startLoop(cb);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  dataMessage(cb) {\r\n    if (!this._fin) {\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    const messageLength = this._messageLength;\r\n    const fragments = this._fragments;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragmented = 0;\r\n    this._fragments = [];\r\n\r\n    if (this._opcode === 2) {\r\n      let data;\r\n\r\n      if (this._binaryType === 'nodebuffer') {\r\n        data = concat(fragments, messageLength);\r\n      } else if (this._binaryType === 'arraybuffer') {\r\n        data = toArrayBuffer(concat(fragments, messageLength));\r\n      } else if (this._binaryType === 'blob') {\r\n        data = new Blob(fragments);\r\n      } else {\r\n        data = fragments;\r\n      }\r\n\r\n      if (this._allowSynchronousEvents) {\r\n        this.emit('message', data, true);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', data, true);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    } else {\r\n      const buf = concat(fragments, messageLength);\r\n\r\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n        const error = this.createError(\r\n          Error,\r\n          'invalid UTF-8 sequence',\r\n          true,\r\n          1007,\r\n          'WS_ERR_INVALID_UTF8'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\r\n        this.emit('message', buf, false);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', buf, false);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  controlMessage(data, cb) {\r\n    if (this._opcode === 0x08) {\r\n      if (data.length === 0) {\r\n        this._loop = false;\r\n        this.emit('conclude', 1005, EMPTY_BUFFER);\r\n        this.end();\r\n      } else {\r\n        const code = data.readUInt16BE(0);\r\n\r\n        if (!isValidStatusCode(code)) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            `invalid status code ${code}`,\r\n            true,\r\n            1002,\r\n            'WS_ERR_INVALID_CLOSE_CODE'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        const buf = new FastBuffer(\r\n          data.buffer,\r\n          data.byteOffset + 2,\r\n          data.length - 2\r\n        );\r\n\r\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n          const error = this.createError(\r\n            Error,\r\n            'invalid UTF-8 sequence',\r\n            true,\r\n            1007,\r\n            'WS_ERR_INVALID_UTF8'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._loop = false;\r\n        this.emit('conclude', code, buf);\r\n        this.end();\r\n      }\r\n\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    if (this._allowSynchronousEvents) {\r\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n      this._state = GET_INFO;\r\n    } else {\r\n      this._state = DEFER_EVENT;\r\n      setImmediate(() => {\r\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n        this._state = GET_INFO;\r\n        this.startLoop(cb);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds an error object.\r\n   *\r\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\r\n   * @param {String} message The error message\r\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\r\n   *     `message`\r\n   * @param {Number} statusCode The status code\r\n   * @param {String} errorCode The exposed error code\r\n   * @return {(Error|RangeError)} The error\r\n   * @private\r\n   */\r\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\r\n    this._loop = false;\r\n    this._errored = true;\r\n\r\n    const err = new ErrorCtor(\r\n      prefix ? `Invalid WebSocket frame: ${message}` : message\r\n    );\r\n\r\n    Error.captureStackTrace(err, this.createError);\r\n    err.code = errorCode;\r\n    err[kStatusCode] = statusCode;\r\n    return err;\r\n  }\r\n}\r\n\r\nmodule.exports = Receiver;\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "../node_modules/ws/lib/sender.js":
/*!****************************************!*\
  !*** ../node_modules/ws/lib/sender.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\r\n\r\n\r\n\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\r\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\r\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\r\n\r\nconst kByteLength = Symbol('kByteLength');\r\nconst maskBuffer = Buffer.alloc(4);\r\nconst RANDOM_POOL_SIZE = 8 * 1024;\r\nlet randomPool;\r\nlet randomPoolPointer = RANDOM_POOL_SIZE;\r\n\r\nconst DEFAULT = 0;\r\nconst DEFLATING = 1;\r\nconst GET_BLOB_DATA = 2;\r\n\r\n/**\r\n * HyBi Sender implementation.\r\n */\r\nclass Sender {\r\n  /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {Duplex} socket The connection socket\r\n   * @param {Object} [extensions] An object containing the negotiated extensions\r\n   * @param {Function} [generateMask] The function used to generate the masking\r\n   *     key\r\n   */\r\n  constructor(socket, extensions, generateMask) {\r\n    this._extensions = extensions || {};\r\n\r\n    if (generateMask) {\r\n      this._generateMask = generateMask;\r\n      this._maskBuffer = Buffer.alloc(4);\r\n    }\r\n\r\n    this._socket = socket;\r\n\r\n    this._firstFragment = true;\r\n    this._compress = false;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._queue = [];\r\n    this._state = DEFAULT;\r\n    this.onerror = NOOP;\r\n    this[kWebSocket] = undefined;\r\n  }\r\n\r\n  /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {(Buffer|String)} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @return {(Buffer|String)[]} The framed data\r\n   * @public\r\n   */\r\n  static frame(data, options) {\r\n    let mask;\r\n    let merge = false;\r\n    let offset = 2;\r\n    let skipMasking = false;\r\n\r\n    if (options.mask) {\r\n      mask = options.maskBuffer || maskBuffer;\r\n\r\n      if (options.generateMask) {\r\n        options.generateMask(mask);\r\n      } else {\r\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\r\n          /* istanbul ignore else  */\r\n          if (randomPool === undefined) {\r\n            //\r\n            // This is lazily initialized because server-sent frames must not\r\n            // be masked so it may never be used.\r\n            //\r\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\r\n          }\r\n\r\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\r\n          randomPoolPointer = 0;\r\n        }\r\n\r\n        mask[0] = randomPool[randomPoolPointer++];\r\n        mask[1] = randomPool[randomPoolPointer++];\r\n        mask[2] = randomPool[randomPoolPointer++];\r\n        mask[3] = randomPool[randomPoolPointer++];\r\n      }\r\n\r\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\r\n      offset = 6;\r\n    }\r\n\r\n    let dataLength;\r\n\r\n    if (typeof data === 'string') {\r\n      if (\r\n        (!options.mask || skipMasking) &&\r\n        options[kByteLength] !== undefined\r\n      ) {\r\n        dataLength = options[kByteLength];\r\n      } else {\r\n        data = Buffer.from(data);\r\n        dataLength = data.length;\r\n      }\r\n    } else {\r\n      dataLength = data.length;\r\n      merge = options.mask && options.readOnly && !skipMasking;\r\n    }\r\n\r\n    let payloadLength = dataLength;\r\n\r\n    if (dataLength >= 65536) {\r\n      offset += 8;\r\n      payloadLength = 127;\r\n    } else if (dataLength > 125) {\r\n      offset += 2;\r\n      payloadLength = 126;\r\n    }\r\n\r\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\r\n\r\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\r\n    if (options.rsv1) target[0] |= 0x40;\r\n\r\n    target[1] = payloadLength;\r\n\r\n    if (payloadLength === 126) {\r\n      target.writeUInt16BE(dataLength, 2);\r\n    } else if (payloadLength === 127) {\r\n      target[2] = target[3] = 0;\r\n      target.writeUIntBE(dataLength, 4, 6);\r\n    }\r\n\r\n    if (!options.mask) return [target, data];\r\n\r\n    target[1] |= 0x80;\r\n    target[offset - 4] = mask[0];\r\n    target[offset - 3] = mask[1];\r\n    target[offset - 2] = mask[2];\r\n    target[offset - 1] = mask[3];\r\n\r\n    if (skipMasking) return [target, data];\r\n\r\n    if (merge) {\r\n      applyMask(data, mask, target, offset, dataLength);\r\n      return [target];\r\n    }\r\n\r\n    applyMask(data, mask, data, 0, dataLength);\r\n    return [target, data];\r\n  }\r\n\r\n  /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {Number} [code] The status code component of the body\r\n   * @param {(String|Buffer)} [data] The message component of the body\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  close(code, data, mask, cb) {\r\n    let buf;\r\n\r\n    if (code === undefined) {\r\n      buf = EMPTY_BUFFER;\r\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\r\n      throw new TypeError('First argument must be a valid error code number');\r\n    } else if (data === undefined || !data.length) {\r\n      buf = Buffer.allocUnsafe(2);\r\n      buf.writeUInt16BE(code, 0);\r\n    } else {\r\n      const length = Buffer.byteLength(data);\r\n\r\n      if (length > 123) {\r\n        throw new RangeError('The message must not be greater than 123 bytes');\r\n      }\r\n\r\n      buf = Buffer.allocUnsafe(2 + length);\r\n      buf.writeUInt16BE(code, 0);\r\n\r\n      if (typeof data === 'string') {\r\n        buf.write(data, 2);\r\n      } else {\r\n        buf.set(data, 2);\r\n      }\r\n    }\r\n\r\n    const options = {\r\n      [kByteLength]: buf.length,\r\n      fin: true,\r\n      generateMask: this._generateMask,\r\n      mask,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode: 0x08,\r\n      readOnly: false,\r\n      rsv1: false\r\n    };\r\n\r\n    if (this._state !== DEFAULT) {\r\n      this.enqueue([this.dispatch, buf, false, options, cb]);\r\n    } else {\r\n      this.sendFrame(Sender.frame(buf, options), cb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  ping(data, mask, cb) {\r\n    let byteLength;\r\n    let readOnly;\r\n\r\n    if (typeof data === 'string') {\r\n      byteLength = Buffer.byteLength(data);\r\n      readOnly = false;\r\n    } else if (isBlob(data)) {\r\n      byteLength = data.size;\r\n      readOnly = false;\r\n    } else {\r\n      data = toBuffer(data);\r\n      byteLength = data.length;\r\n      readOnly = toBuffer.readOnly;\r\n    }\r\n\r\n    if (byteLength > 125) {\r\n      throw new RangeError('The data size must not be greater than 125 bytes');\r\n    }\r\n\r\n    const options = {\r\n      [kByteLength]: byteLength,\r\n      fin: true,\r\n      generateMask: this._generateMask,\r\n      mask,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode: 0x09,\r\n      readOnly,\r\n      rsv1: false\r\n    };\r\n\r\n    if (isBlob(data)) {\r\n      if (this._state !== DEFAULT) {\r\n        this.enqueue([this.getBlobData, data, false, options, cb]);\r\n      } else {\r\n        this.getBlobData(data, false, options, cb);\r\n      }\r\n    } else if (this._state !== DEFAULT) {\r\n      this.enqueue([this.dispatch, data, false, options, cb]);\r\n    } else {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  pong(data, mask, cb) {\r\n    let byteLength;\r\n    let readOnly;\r\n\r\n    if (typeof data === 'string') {\r\n      byteLength = Buffer.byteLength(data);\r\n      readOnly = false;\r\n    } else if (isBlob(data)) {\r\n      byteLength = data.size;\r\n      readOnly = false;\r\n    } else {\r\n      data = toBuffer(data);\r\n      byteLength = data.length;\r\n      readOnly = toBuffer.readOnly;\r\n    }\r\n\r\n    if (byteLength > 125) {\r\n      throw new RangeError('The data size must not be greater than 125 bytes');\r\n    }\r\n\r\n    const options = {\r\n      [kByteLength]: byteLength,\r\n      fin: true,\r\n      generateMask: this._generateMask,\r\n      mask,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode: 0x0a,\r\n      readOnly,\r\n      rsv1: false\r\n    };\r\n\r\n    if (isBlob(data)) {\r\n      if (this._state !== DEFAULT) {\r\n        this.enqueue([this.getBlobData, data, false, options, cb]);\r\n      } else {\r\n        this.getBlobData(data, false, options, cb);\r\n      }\r\n    } else if (this._state !== DEFAULT) {\r\n      this.enqueue([this.dispatch, data, false, options, cb]);\r\n    } else {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\r\n   *     or text\r\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\r\n   *     compress `data`\r\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n    let opcode = options.binary ? 2 : 1;\r\n    let rsv1 = options.compress;\r\n\r\n    let byteLength;\r\n    let readOnly;\r\n\r\n    if (typeof data === 'string') {\r\n      byteLength = Buffer.byteLength(data);\r\n      readOnly = false;\r\n    } else if (isBlob(data)) {\r\n      byteLength = data.size;\r\n      readOnly = false;\r\n    } else {\r\n      data = toBuffer(data);\r\n      byteLength = data.length;\r\n      readOnly = toBuffer.readOnly;\r\n    }\r\n\r\n    if (this._firstFragment) {\r\n      this._firstFragment = false;\r\n      if (\r\n        rsv1 &&\r\n        perMessageDeflate &&\r\n        perMessageDeflate.params[\r\n          perMessageDeflate._isServer\r\n            ? 'server_no_context_takeover'\r\n            : 'client_no_context_takeover'\r\n        ]\r\n      ) {\r\n        rsv1 = byteLength >= perMessageDeflate._threshold;\r\n      }\r\n      this._compress = rsv1;\r\n    } else {\r\n      rsv1 = false;\r\n      opcode = 0;\r\n    }\r\n\r\n    if (options.fin) this._firstFragment = true;\r\n\r\n    const opts = {\r\n      [kByteLength]: byteLength,\r\n      fin: options.fin,\r\n      generateMask: this._generateMask,\r\n      mask: options.mask,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode,\r\n      readOnly,\r\n      rsv1\r\n    };\r\n\r\n    if (isBlob(data)) {\r\n      if (this._state !== DEFAULT) {\r\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\r\n      } else {\r\n        this.getBlobData(data, this._compress, opts, cb);\r\n      }\r\n    } else if (this._state !== DEFAULT) {\r\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\r\n    } else {\r\n      this.dispatch(data, this._compress, opts, cb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the contents of a blob as binary data.\r\n   *\r\n   * @param {Blob} blob The blob\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     the data\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\r\n  getBlobData(blob, compress, options, cb) {\r\n    this._bufferedBytes += options[kByteLength];\r\n    this._state = GET_BLOB_DATA;\r\n\r\n    blob\r\n      .arrayBuffer()\r\n      .then((arrayBuffer) => {\r\n        if (this._socket.destroyed) {\r\n          const err = new Error(\r\n            'The socket was closed while the blob was being read'\r\n          );\r\n\r\n          //\r\n          // `callCallbacks` is called in the next tick to ensure that errors\r\n          // that might be thrown in the callbacks behave like errors thrown\r\n          // outside the promise chain.\r\n          //\r\n          process.nextTick(callCallbacks, this, err, cb);\r\n          return;\r\n        }\r\n\r\n        this._bufferedBytes -= options[kByteLength];\r\n        const data = toBuffer(arrayBuffer);\r\n\r\n        if (!compress) {\r\n          this._state = DEFAULT;\r\n          this.sendFrame(Sender.frame(data, options), cb);\r\n          this.dequeue();\r\n        } else {\r\n          this.dispatch(data, compress, options, cb);\r\n        }\r\n      })\r\n      .catch((err) => {\r\n        //\r\n        // `onError` is called in the next tick for the same reason that\r\n        // `callCallbacks` above is.\r\n        //\r\n        process.nextTick(onError, this, err, cb);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Dispatches a message.\r\n   *\r\n   * @param {(Buffer|String)} data The message to send\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\r\n  dispatch(data, compress, options, cb) {\r\n    if (!compress) {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n      return;\r\n    }\r\n\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    this._bufferedBytes += options[kByteLength];\r\n    this._state = DEFLATING;\r\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\r\n      if (this._socket.destroyed) {\r\n        const err = new Error(\r\n          'The socket was closed while data was being compressed'\r\n        );\r\n\r\n        callCallbacks(this, err, cb);\r\n        return;\r\n      }\r\n\r\n      this._bufferedBytes -= options[kByteLength];\r\n      this._state = DEFAULT;\r\n      options.readOnly = false;\r\n      this.sendFrame(Sender.frame(buf, options), cb);\r\n      this.dequeue();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */\r\n  dequeue() {\r\n    while (this._state === DEFAULT && this._queue.length) {\r\n      const params = this._queue.shift();\r\n\r\n      this._bufferedBytes -= params[3][kByteLength];\r\n      Reflect.apply(params[0], this, params.slice(1));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */\r\n  enqueue(params) {\r\n    this._bufferedBytes += params[3][kByteLength];\r\n    this._queue.push(params);\r\n  }\r\n\r\n  /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {Buffer[]} list The frame to send\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\r\n  sendFrame(list, cb) {\r\n    if (list.length === 2) {\r\n      this._socket.cork();\r\n      this._socket.write(list[0]);\r\n      this._socket.write(list[1], cb);\r\n      this._socket.uncork();\r\n    } else {\r\n      this._socket.write(list[0], cb);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Sender;\r\n\r\n/**\r\n * Calls queued callbacks with an error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error to call the callbacks with\r\n * @param {Function} [cb] The first callback\r\n * @private\r\n */\r\nfunction callCallbacks(sender, err, cb) {\r\n  if (typeof cb === 'function') cb(err);\r\n\r\n  for (let i = 0; i < sender._queue.length; i++) {\r\n    const params = sender._queue[i];\r\n    const callback = params[params.length - 1];\r\n\r\n    if (typeof callback === 'function') callback(err);\r\n  }\r\n}\r\n\r\n/**\r\n * Handles a `Sender` error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error\r\n * @param {Function} [cb] The first pending callback\r\n * @private\r\n */\r\nfunction onError(sender, err, cb) {\r\n  callCallbacks(sender, err, cb);\r\n  sender.onerror(err);\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "../node_modules/ws/lib/stream.js":
/*!****************************************!*\
  !*** ../node_modules/ws/lib/stream.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\n/**\r\n * Emits the `'close'` event on a stream.\r\n *\r\n * @param {Duplex} stream The stream.\r\n * @private\r\n */\r\nfunction emitClose(stream) {\r\n  stream.emit('close');\r\n}\r\n\r\n/**\r\n * The listener of the `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction duplexOnEnd() {\r\n  if (!this.destroyed && this._writableState.finished) {\r\n    this.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `'error'` event.\r\n *\r\n * @param {Error} err The error\r\n * @private\r\n */\r\nfunction duplexOnError(err) {\r\n  this.removeListener('error', duplexOnError);\r\n  this.destroy();\r\n  if (this.listenerCount('error') === 0) {\r\n    // Do not suppress the throwing behavior.\r\n    this.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Wraps a `WebSocket` in a duplex stream.\r\n *\r\n * @param {WebSocket} ws The `WebSocket` to wrap\r\n * @param {Object} [options] The options for the `Duplex` constructor\r\n * @return {Duplex} The duplex stream\r\n * @public\r\n */\r\nfunction createWebSocketStream(ws, options) {\r\n  let terminateOnDestroy = true;\r\n\r\n  const duplex = new Duplex({\r\n    ...options,\r\n    autoDestroy: false,\r\n    emitClose: false,\r\n    objectMode: false,\r\n    writableObjectMode: false\r\n  });\r\n\r\n  ws.on('message', function message(msg, isBinary) {\r\n    const data =\r\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\r\n\r\n    if (!duplex.push(data)) ws.pause();\r\n  });\r\n\r\n  ws.once('error', function error(err) {\r\n    if (duplex.destroyed) return;\r\n\r\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\r\n    //\r\n    // - If the `'error'` event is emitted before the `'open'` event, then\r\n    //   `ws.terminate()` is a noop as no socket is assigned.\r\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\r\n    //   event of the `Receiver` object. The listener already closes the\r\n    //   connection by calling `ws.close()`. This allows a close frame to be\r\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\r\n    //   then the close frame might not be sent.\r\n    terminateOnDestroy = false;\r\n    duplex.destroy(err);\r\n  });\r\n\r\n  ws.once('close', function close() {\r\n    if (duplex.destroyed) return;\r\n\r\n    duplex.push(null);\r\n  });\r\n\r\n  duplex._destroy = function (err, callback) {\r\n    if (ws.readyState === ws.CLOSED) {\r\n      callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n      return;\r\n    }\r\n\r\n    let called = false;\r\n\r\n    ws.once('error', function error(err) {\r\n      called = true;\r\n      callback(err);\r\n    });\r\n\r\n    ws.once('close', function close() {\r\n      if (!called) callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n    });\r\n\r\n    if (terminateOnDestroy) ws.terminate();\r\n  };\r\n\r\n  duplex._final = function (callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._final(callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    // If the value of the `_socket` property is `null` it means that `ws` is a\r\n    // client websocket and the handshake failed. In fact, when this happens, a\r\n    // socket is never assigned to the websocket. Wait for the `'error'` event\r\n    // that will be emitted by the websocket.\r\n    if (ws._socket === null) return;\r\n\r\n    if (ws._socket._writableState.finished) {\r\n      callback();\r\n      if (duplex._readableState.endEmitted) duplex.destroy();\r\n    } else {\r\n      ws._socket.once('finish', function finish() {\r\n        // `duplex` is not destroyed here because the `'end'` event will be\r\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\r\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\r\n        callback();\r\n      });\r\n      ws.close();\r\n    }\r\n  };\r\n\r\n  duplex._read = function () {\r\n    if (ws.isPaused) ws.resume();\r\n  };\r\n\r\n  duplex._write = function (chunk, encoding, callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._write(chunk, encoding, callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    ws.send(chunk, callback);\r\n  };\r\n\r\n  duplex.on('end', duplexOnEnd);\r\n  duplex.on('error', duplexOnError);\r\n  return duplex;\r\n}\r\n\r\nmodule.exports = createWebSocketStream;\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/stream.js?");

/***/ }),

/***/ "../node_modules/ws/lib/subprotocol.js":
/*!*********************************************!*\
  !*** ../node_modules/ws/lib/subprotocol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Set} The subprotocol names\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const protocols = new Set();\r\n  let start = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (i; i < header.length; i++) {\r\n    const code = header.charCodeAt(i);\r\n\r\n    if (end === -1 && tokenChars[code] === 1) {\r\n      if (start === -1) start = i;\r\n    } else if (\r\n      i !== 0 &&\r\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n    ) {\r\n      if (end === -1 && start !== -1) end = i;\r\n    } else if (code === 0x2c /* ',' */) {\r\n      if (start === -1) {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n\r\n      if (end === -1) end = i;\r\n\r\n      const protocol = header.slice(start, end);\r\n\r\n      if (protocols.has(protocol)) {\r\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n      }\r\n\r\n      protocols.add(protocol);\r\n      start = end = -1;\r\n    } else {\r\n      throw new SyntaxError(`Unexpected character at index ${i}`);\r\n    }\r\n  }\r\n\r\n  if (start === -1 || end !== -1) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  const protocol = header.slice(start, i);\r\n\r\n  if (protocols.has(protocol)) {\r\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n  }\r\n\r\n  protocols.add(protocol);\r\n  return protocols;\r\n}\r\n\r\nmodule.exports = { parse };\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/subprotocol.js?");

/***/ }),

/***/ "../node_modules/ws/lib/validation.js":
/*!********************************************!*\
  !*** ../node_modules/ws/lib/validation.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\r\n\r\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\n\r\n//\r\n// Allowed token characters:\r\n//\r\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\r\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\r\n//\r\n// tokenChars[32] === 0 // ' '\r\n// tokenChars[33] === 1 // '!'\r\n// tokenChars[34] === 0 // '\"'\r\n// ...\r\n//\r\n// prettier-ignore\r\nconst tokenChars = [\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\r\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\r\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\r\n];\r\n\r\n/**\r\n * Checks if a status code is allowed in a close frame.\r\n *\r\n * @param {Number} code The status code\r\n * @return {Boolean} `true` if the status code is valid, else `false`\r\n * @public\r\n */\r\nfunction isValidStatusCode(code) {\r\n  return (\r\n    (code >= 1000 &&\r\n      code <= 1014 &&\r\n      code !== 1004 &&\r\n      code !== 1005 &&\r\n      code !== 1006) ||\r\n    (code >= 3000 && code <= 4999)\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if a given buffer contains only correct UTF-8.\r\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\r\n * Markus Kuhn.\r\n *\r\n * @param {Buffer} buf The buffer to check\r\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\r\n * @public\r\n */\r\nfunction _isValidUTF8(buf) {\r\n  const len = buf.length;\r\n  let i = 0;\r\n\r\n  while (i < len) {\r\n    if ((buf[i] & 0x80) === 0) {\r\n      // 0xxxxxxx\r\n      i++;\r\n    } else if ((buf[i] & 0xe0) === 0xc0) {\r\n      // 110xxxxx 10xxxxxx\r\n      if (\r\n        i + 1 === len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i] & 0xfe) === 0xc0 // Overlong\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 2;\r\n    } else if ((buf[i] & 0xf0) === 0xe0) {\r\n      // 1110xxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 2 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\r\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 3;\r\n    } else if ((buf[i] & 0xf8) === 0xf0) {\r\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 3 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i + 3] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\r\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\r\n        buf[i] > 0xf4 // > U+10FFFF\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 4;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines whether a value is a `Blob`.\r\n *\r\n * @param {*} value The value to be tested\r\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\r\n * @private\r\n */\r\nfunction isBlob(value) {\r\n  return (\r\n    hasBlob &&\r\n    typeof value === 'object' &&\r\n    typeof value.arrayBuffer === 'function' &&\r\n    typeof value.type === 'string' &&\r\n    typeof value.stream === 'function' &&\r\n    (value[Symbol.toStringTag] === 'Blob' ||\r\n      value[Symbol.toStringTag] === 'File')\r\n  );\r\n}\r\n\r\nmodule.exports = {\r\n  isBlob,\r\n  isValidStatusCode,\r\n  isValidUTF8: _isValidUTF8,\r\n  tokenChars\r\n};\r\n\r\nif (isUtf8) {\r\n  module.exports.isValidUTF8 = function (buf) {\r\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\r\n  };\r\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\r\n  try {\r\n    const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\n\r\n    module.exports.isValidUTF8 = function (buf) {\r\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "../node_modules/ws/lib/websocket-server.js":
/*!**************************************************!*\
  !*** ../node_modules/ws/lib/websocket-server.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\nconst extension = __webpack_require__(/*! ./extension */ \"../node_modules/ws/lib/extension.js\");\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\r\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"../node_modules/ws/lib/subprotocol.js\");\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"../node_modules/ws/lib/websocket.js\");\r\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\n\r\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\r\n\r\nconst RUNNING = 0;\r\nconst CLOSING = 1;\r\nconst CLOSED = 2;\r\n\r\n/**\r\n * Class representing a WebSocket server.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocketServer extends EventEmitter {\r\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n   *     automatically send a pong in response to a ping\r\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\r\n   *     pending connections\r\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\r\n   *     track clients\r\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\r\n   * @param {String} [options.host] The hostname where to bind the server\r\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n   *     size\r\n   * @param {Boolean} [options.noServer=false] Enable no server mode\r\n   * @param {String} [options.path] Accept only connections matching this path\r\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\r\n   *     permessage-deflate\r\n   * @param {Number} [options.port] The port where to bind the server\r\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\r\n   *     server to use\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @param {Function} [options.verifyClient] A hook to reject connections\r\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\r\n   *     class to use. It must be the `WebSocket` class or class that extends it\r\n   * @param {Function} [callback] A listener for the `listening` event\r\n   */\r\n  constructor(options, callback) {\r\n    super();\r\n\r\n    options = {\r\n      allowSynchronousEvents: true,\r\n      autoPong: true,\r\n      maxPayload: 100 * 1024 * 1024,\r\n      skipUTF8Validation: false,\r\n      perMessageDeflate: false,\r\n      handleProtocols: null,\r\n      clientTracking: true,\r\n      verifyClient: null,\r\n      noServer: false,\r\n      backlog: null, // use default (511 as implemented in net.js)\r\n      server: null,\r\n      host: null,\r\n      path: null,\r\n      port: null,\r\n      WebSocket,\r\n      ...options\r\n    };\r\n\r\n    if (\r\n      (options.port == null && !options.server && !options.noServer) ||\r\n      (options.port != null && (options.server || options.noServer)) ||\r\n      (options.server && options.noServer)\r\n    ) {\r\n      throw new TypeError(\r\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\r\n          'must be specified'\r\n      );\r\n    }\r\n\r\n    if (options.port != null) {\r\n      this._server = http.createServer((req, res) => {\r\n        const body = http.STATUS_CODES[426];\r\n\r\n        res.writeHead(426, {\r\n          'Content-Length': body.length,\r\n          'Content-Type': 'text/plain'\r\n        });\r\n        res.end(body);\r\n      });\r\n      this._server.listen(\r\n        options.port,\r\n        options.host,\r\n        options.backlog,\r\n        callback\r\n      );\r\n    } else if (options.server) {\r\n      this._server = options.server;\r\n    }\r\n\r\n    if (this._server) {\r\n      const emitConnection = this.emit.bind(this, 'connection');\r\n\r\n      this._removeListeners = addListeners(this._server, {\r\n        listening: this.emit.bind(this, 'listening'),\r\n        error: this.emit.bind(this, 'error'),\r\n        upgrade: (req, socket, head) => {\r\n          this.handleUpgrade(req, socket, head, emitConnection);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\r\n    if (options.clientTracking) {\r\n      this.clients = new Set();\r\n      this._shouldEmitClose = false;\r\n    }\r\n\r\n    this.options = options;\r\n    this._state = RUNNING;\r\n  }\r\n\r\n  /**\r\n   * Returns the bound address, the address family name, and port of the server\r\n   * as reported by the operating system if listening on an IP socket.\r\n   * If the server is listening on a pipe or UNIX domain socket, the name is\r\n   * returned as a string.\r\n   *\r\n   * @return {(Object|String|null)} The address of the server\r\n   * @public\r\n   */\r\n  address() {\r\n    if (this.options.noServer) {\r\n      throw new Error('The server is operating in \"noServer\" mode');\r\n    }\r\n\r\n    if (!this._server) return null;\r\n    return this._server.address();\r\n  }\r\n\r\n  /**\r\n   * Stop the server from accepting new connections and emit the `'close'` event\r\n   * when all existing connections are closed.\r\n   *\r\n   * @param {Function} [cb] A one-time listener for the `'close'` event\r\n   * @public\r\n   */\r\n  close(cb) {\r\n    if (this._state === CLOSED) {\r\n      if (cb) {\r\n        this.once('close', () => {\r\n          cb(new Error('The server is not running'));\r\n        });\r\n      }\r\n\r\n      process.nextTick(emitClose, this);\r\n      return;\r\n    }\r\n\r\n    if (cb) this.once('close', cb);\r\n\r\n    if (this._state === CLOSING) return;\r\n    this._state = CLOSING;\r\n\r\n    if (this.options.noServer || this.options.server) {\r\n      if (this._server) {\r\n        this._removeListeners();\r\n        this._removeListeners = this._server = null;\r\n      }\r\n\r\n      if (this.clients) {\r\n        if (!this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        } else {\r\n          this._shouldEmitClose = true;\r\n        }\r\n      } else {\r\n        process.nextTick(emitClose, this);\r\n      }\r\n    } else {\r\n      const server = this._server;\r\n\r\n      this._removeListeners();\r\n      this._removeListeners = this._server = null;\r\n\r\n      //\r\n      // The HTTP/S server was created internally. Close it, and rely on its\r\n      // `'close'` event.\r\n      //\r\n      server.close(() => {\r\n        emitClose(this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\r\n  shouldHandle(req) {\r\n    if (this.options.path) {\r\n      const index = req.url.indexOf('?');\r\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\r\n\r\n      if (pathname !== this.options.path) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  handleUpgrade(req, socket, head, cb) {\r\n    socket.on('error', socketOnError);\r\n\r\n    const key = req.headers['sec-websocket-key'];\r\n    const upgrade = req.headers.upgrade;\r\n    const version = +req.headers['sec-websocket-version'];\r\n\r\n    if (req.method !== 'GET') {\r\n      const message = 'Invalid HTTP method';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\r\n      return;\r\n    }\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      const message = 'Invalid Upgrade header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (key === undefined || !keyRegex.test(key)) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (version !== 8 && version !== 13) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (!this.shouldHandle(req)) {\r\n      abortHandshake(socket, 400);\r\n      return;\r\n    }\r\n\r\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\r\n    let protocols = new Set();\r\n\r\n    if (secWebSocketProtocol !== undefined) {\r\n      try {\r\n        protocols = subprotocol.parse(secWebSocketProtocol);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Protocol header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\r\n    const extensions = {};\r\n\r\n    if (\r\n      this.options.perMessageDeflate &&\r\n      secWebSocketExtensions !== undefined\r\n    ) {\r\n      const perMessageDeflate = new PerMessageDeflate(\r\n        this.options.perMessageDeflate,\r\n        true,\r\n        this.options.maxPayload\r\n      );\r\n\r\n      try {\r\n        const offers = extension.parse(secWebSocketExtensions);\r\n\r\n        if (offers[PerMessageDeflate.extensionName]) {\r\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\r\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        const message =\r\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Optionally call external client verification handler.\r\n    //\r\n    if (this.options.verifyClient) {\r\n      const info = {\r\n        origin:\r\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\r\n        secure: !!(req.socket.authorized || req.socket.encrypted),\r\n        req\r\n      };\r\n\r\n      if (this.options.verifyClient.length === 2) {\r\n        this.options.verifyClient(info, (verified, code, message, headers) => {\r\n          if (!verified) {\r\n            return abortHandshake(socket, code || 401, message, headers);\r\n          }\r\n\r\n          this.completeUpgrade(\r\n            extensions,\r\n            key,\r\n            protocols,\r\n            req,\r\n            socket,\r\n            head,\r\n            cb\r\n          );\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\r\n    }\r\n\r\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\r\n  }\r\n\r\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\r\n   * @param {Set} protocols The subprotocols\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @throws {Error} If called more than once with the same socket\r\n   * @private\r\n   */\r\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\r\n    //\r\n    // Destroy the socket if the client has already sent a FIN packet.\r\n    //\r\n    if (!socket.readable || !socket.writable) return socket.destroy();\r\n\r\n    if (socket[kWebSocket]) {\r\n      throw new Error(\r\n        'server.handleUpgrade() was called more than once with the same ' +\r\n          'socket, possibly due to a misconfiguration'\r\n      );\r\n    }\r\n\r\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    const headers = [\r\n      'HTTP/1.1 101 Switching Protocols',\r\n      'Upgrade: websocket',\r\n      'Connection: Upgrade',\r\n      `Sec-WebSocket-Accept: ${digest}`\r\n    ];\r\n\r\n    const ws = new this.options.WebSocket(null, undefined, this.options);\r\n\r\n    if (protocols.size) {\r\n      //\r\n      // Optionally call external protocol selection handler.\r\n      //\r\n      const protocol = this.options.handleProtocols\r\n        ? this.options.handleProtocols(protocols, req)\r\n        : protocols.values().next().value;\r\n\r\n      if (protocol) {\r\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\r\n        ws._protocol = protocol;\r\n      }\r\n    }\r\n\r\n    if (extensions[PerMessageDeflate.extensionName]) {\r\n      const params = extensions[PerMessageDeflate.extensionName].params;\r\n      const value = extension.format({\r\n        [PerMessageDeflate.extensionName]: [params]\r\n      });\r\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\r\n      ws._extensions = extensions;\r\n    }\r\n\r\n    //\r\n    // Allow external modification/inspection of handshake headers.\r\n    //\r\n    this.emit('headers', headers, req);\r\n\r\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\r\n    socket.removeListener('error', socketOnError);\r\n\r\n    ws.setSocket(socket, head, {\r\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\r\n      maxPayload: this.options.maxPayload,\r\n      skipUTF8Validation: this.options.skipUTF8Validation\r\n    });\r\n\r\n    if (this.clients) {\r\n      this.clients.add(ws);\r\n      ws.on('close', () => {\r\n        this.clients.delete(ws);\r\n\r\n        if (this._shouldEmitClose && !this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        }\r\n      });\r\n    }\r\n\r\n    cb(ws, req);\r\n  }\r\n}\r\n\r\nmodule.exports = WebSocketServer;\r\n\r\n/**\r\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\r\n * pairs.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @param {Object.<String, Function>} map The listeners to add\r\n * @return {Function} A function that will remove the added listeners when\r\n *     called\r\n * @private\r\n */\r\nfunction addListeners(server, map) {\r\n  for (const event of Object.keys(map)) server.on(event, map[event]);\r\n\r\n  return function removeListeners() {\r\n    for (const event of Object.keys(map)) {\r\n      server.removeListener(event, map[event]);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Emit a `'close'` event on an `EventEmitter`.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @private\r\n */\r\nfunction emitClose(server) {\r\n  server._state = CLOSED;\r\n  server.emit('close');\r\n}\r\n\r\n/**\r\n * Handle socket errors.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  this.destroy();\r\n}\r\n\r\n/**\r\n * Close the connection when preconditions are not fulfilled.\r\n *\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} [message] The HTTP response body\r\n * @param {Object} [headers] Additional HTTP response headers\r\n * @private\r\n */\r\nfunction abortHandshake(socket, code, message, headers) {\r\n  //\r\n  // The socket is writable unless the user destroyed or ended it before calling\r\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\r\n  // error. Handling this does not make much sense as the worst that can happen\r\n  // is that some of the data written by the user might be discarded due to the\r\n  // call to `socket.end()` below, which triggers an `'error'` event that in\r\n  // turn causes the socket to be destroyed.\r\n  //\r\n  message = message || http.STATUS_CODES[code];\r\n  headers = {\r\n    Connection: 'close',\r\n    'Content-Type': 'text/html',\r\n    'Content-Length': Buffer.byteLength(message),\r\n    ...headers\r\n  };\r\n\r\n  socket.once('finish', socket.destroy);\r\n\r\n  socket.end(\r\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\r\n      Object.keys(headers)\r\n        .map((h) => `${h}: ${headers[h]}`)\r\n        .join('\\r\\n') +\r\n      '\\r\\n\\r\\n' +\r\n      message\r\n  );\r\n}\r\n\r\n/**\r\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\r\n * one listener for it, otherwise call `abortHandshake()`.\r\n *\r\n * @param {WebSocketServer} server The WebSocket server\r\n * @param {http.IncomingMessage} req The request object\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} message The HTTP response body\r\n * @private\r\n */\r\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\r\n  if (server.listenerCount('wsClientError')) {\r\n    const err = new Error(message);\r\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\r\n\r\n    server.emit('wsClientError', err, socket, req);\r\n  } else {\r\n    abortHandshake(socket, code, message);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "../node_modules/ws/lib/websocket.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/websocket.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst https = __webpack_require__(/*! https */ \"https\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst net = __webpack_require__(/*! net */ \"net\");\r\nconst tls = __webpack_require__(/*! tls */ \"tls\");\r\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { URL } = __webpack_require__(/*! url */ \"url\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\r\nconst Receiver = __webpack_require__(/*! ./receiver */ \"../node_modules/ws/lib/receiver.js\");\r\nconst Sender = __webpack_require__(/*! ./sender */ \"../node_modules/ws/lib/sender.js\");\r\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\r\n\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  GUID,\r\n  kForOnEventAttribute,\r\n  kListener,\r\n  kStatusCode,\r\n  kWebSocket,\r\n  NOOP\r\n} = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\r\nconst {\r\n  EventTarget: { addEventListener, removeEventListener }\r\n} = __webpack_require__(/*! ./event-target */ \"../node_modules/ws/lib/event-target.js\");\r\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"../node_modules/ws/lib/extension.js\");\r\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\r\n\r\nconst closeTimeout = 30 * 1000;\r\nconst kAborted = Symbol('kAborted');\r\nconst protocolVersions = [8, 13];\r\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\r\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\r\n\r\n/**\r\n * Class representing a WebSocket.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocket extends EventEmitter {\r\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {(String|URL)} address The URL to which to connect\r\n   * @param {(String|String[])} [protocols] The subprotocols\r\n   * @param {Object} [options] Connection options\r\n   */\r\n  constructor(address, protocols, options) {\r\n    super();\r\n\r\n    this._binaryType = BINARY_TYPES[0];\r\n    this._closeCode = 1006;\r\n    this._closeFrameReceived = false;\r\n    this._closeFrameSent = false;\r\n    this._closeMessage = EMPTY_BUFFER;\r\n    this._closeTimer = null;\r\n    this._errorEmitted = false;\r\n    this._extensions = {};\r\n    this._paused = false;\r\n    this._protocol = '';\r\n    this._readyState = WebSocket.CONNECTING;\r\n    this._receiver = null;\r\n    this._sender = null;\r\n    this._socket = null;\r\n\r\n    if (address !== null) {\r\n      this._bufferedAmount = 0;\r\n      this._isServer = false;\r\n      this._redirects = 0;\r\n\r\n      if (protocols === undefined) {\r\n        protocols = [];\r\n      } else if (!Array.isArray(protocols)) {\r\n        if (typeof protocols === 'object' && protocols !== null) {\r\n          options = protocols;\r\n          protocols = [];\r\n        } else {\r\n          protocols = [protocols];\r\n        }\r\n      }\r\n\r\n      initAsClient(this, address, protocols, options);\r\n    } else {\r\n      this._autoPong = options.autoPong;\r\n      this._isServer = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\r\n   * instead of \"blob\".\r\n   *\r\n   * @type {String}\r\n   */\r\n  get binaryType() {\r\n    return this._binaryType;\r\n  }\r\n\r\n  set binaryType(type) {\r\n    if (!BINARY_TYPES.includes(type)) return;\r\n\r\n    this._binaryType = type;\r\n\r\n    //\r\n    // Allow to change `binaryType` on the fly.\r\n    //\r\n    if (this._receiver) this._receiver._binaryType = type;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get bufferedAmount() {\r\n    if (!this._socket) return this._bufferedAmount;\r\n\r\n    return this._socket._writableState.length + this._sender._bufferedBytes;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get extensions() {\r\n    return Object.keys(this._extensions).join();\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get isPaused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onclose() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onerror() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onopen() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onmessage() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get protocol() {\r\n    return this._protocol;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get readyState() {\r\n    return this._readyState;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get url() {\r\n    return this._url;\r\n  }\r\n\r\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @private\r\n   */\r\n  setSocket(socket, head, options) {\r\n    const receiver = new Receiver({\r\n      allowSynchronousEvents: options.allowSynchronousEvents,\r\n      binaryType: this.binaryType,\r\n      extensions: this._extensions,\r\n      isServer: this._isServer,\r\n      maxPayload: options.maxPayload,\r\n      skipUTF8Validation: options.skipUTF8Validation\r\n    });\r\n\r\n    const sender = new Sender(socket, this._extensions, options.generateMask);\r\n\r\n    this._receiver = receiver;\r\n    this._sender = sender;\r\n    this._socket = socket;\r\n\r\n    receiver[kWebSocket] = this;\r\n    sender[kWebSocket] = this;\r\n    socket[kWebSocket] = this;\r\n\r\n    receiver.on('conclude', receiverOnConclude);\r\n    receiver.on('drain', receiverOnDrain);\r\n    receiver.on('error', receiverOnError);\r\n    receiver.on('message', receiverOnMessage);\r\n    receiver.on('ping', receiverOnPing);\r\n    receiver.on('pong', receiverOnPong);\r\n\r\n    sender.onerror = senderOnError;\r\n\r\n    //\r\n    // These methods may not be available if `socket` is just a `Duplex`.\r\n    //\r\n    if (socket.setTimeout) socket.setTimeout(0);\r\n    if (socket.setNoDelay) socket.setNoDelay();\r\n\r\n    if (head.length > 0) socket.unshift(head);\r\n\r\n    socket.on('close', socketOnClose);\r\n    socket.on('data', socketOnData);\r\n    socket.on('end', socketOnEnd);\r\n    socket.on('error', socketOnError);\r\n\r\n    this._readyState = WebSocket.OPEN;\r\n    this.emit('open');\r\n  }\r\n\r\n  /**\r\n   * Emit the `'close'` event.\r\n   *\r\n   * @private\r\n   */\r\n  emitClose() {\r\n    if (!this._socket) {\r\n      this._readyState = WebSocket.CLOSED;\r\n      this.emit('close', this._closeCode, this._closeMessage);\r\n      return;\r\n    }\r\n\r\n    if (this._extensions[PerMessageDeflate.extensionName]) {\r\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\r\n    }\r\n\r\n    this._receiver.removeAllListeners();\r\n    this._readyState = WebSocket.CLOSED;\r\n    this.emit('close', this._closeCode, this._closeMessage);\r\n  }\r\n\r\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *          +----------+   +-----------+   +----------+\r\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\r\n   *    |     +----------+   +-----------+   +----------+     |\r\n   *          +----------+   +-----------+         |\r\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\r\n   *          +----------+   +-----------+   |\r\n   *    |           |                        |   +---+        |\r\n   *                +------------------------+-->|fin| - - - -\r\n   *    |         +---+                      |   +---+\r\n   *     - - - - -|fin|<---------------------+\r\n   *              +---+\r\n   *\r\n   * @param {Number} [code] Status code explaining why the connection is closing\r\n   * @param {(String|Buffer)} [data] The reason why the connection is\r\n   *     closing\r\n   * @public\r\n   */\r\n  close(code, data) {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this.readyState === WebSocket.CLOSING) {\r\n      if (\r\n        this._closeFrameSent &&\r\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this._readyState = WebSocket.CLOSING;\r\n    this._sender.close(code, data, !this._isServer, (err) => {\r\n      //\r\n      // This error is handled by the `'error'` listener on the socket. We only\r\n      // want to know if the close frame has been sent here.\r\n      //\r\n      if (err) return;\r\n\r\n      this._closeFrameSent = true;\r\n\r\n      if (\r\n        this._closeFrameReceived ||\r\n        this._receiver._writableState.errorEmitted\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n    });\r\n\r\n    setCloseTimer(this);\r\n  }\r\n\r\n  /**\r\n   * Pause the socket.\r\n   *\r\n   * @public\r\n   */\r\n  pause() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = true;\r\n    this._socket.pause();\r\n  }\r\n\r\n  /**\r\n   * Send a ping.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the ping is sent\r\n   * @public\r\n   */\r\n  ping(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Send a pong.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the pong is sent\r\n   * @public\r\n   */\r\n  pong(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Resume the socket.\r\n   *\r\n   * @public\r\n   */\r\n  resume() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = false;\r\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\r\n  }\r\n\r\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\r\n   *     text\r\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when data is written out\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof options === 'function') {\r\n      cb = options;\r\n      options = {};\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    const opts = {\r\n      binary: typeof data !== 'string',\r\n      mask: !this._isServer,\r\n      compress: true,\r\n      fin: true,\r\n      ...options\r\n    };\r\n\r\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\r\n      opts.compress = false;\r\n    }\r\n\r\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\r\n  }\r\n\r\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\r\n  terminate() {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this._socket) {\r\n      this._readyState = WebSocket.CLOSING;\r\n      this._socket.destroy();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n[\r\n  'binaryType',\r\n  'bufferedAmount',\r\n  'extensions',\r\n  'isPaused',\r\n  'protocol',\r\n  'readyState',\r\n  'url'\r\n].forEach((property) => {\r\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\r\n});\r\n\r\n//\r\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\r\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\r\n//\r\n['open', 'error', 'close', 'message'].forEach((method) => {\r\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\r\n    enumerable: true,\r\n    get() {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) return listener[kListener];\r\n      }\r\n\r\n      return null;\r\n    },\r\n    set(handler) {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) {\r\n          this.removeListener(method, listener);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (typeof handler !== 'function') return;\r\n\r\n      this.addEventListener(method, handler, {\r\n        [kForOnEventAttribute]: true\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nWebSocket.prototype.addEventListener = addEventListener;\r\nWebSocket.prototype.removeEventListener = removeEventListener;\r\n\r\nmodule.exports = WebSocket;\r\n\r\n/**\r\n * Initialize a WebSocket client.\r\n *\r\n * @param {WebSocket} websocket The client to initialize\r\n * @param {(String|URL)} address The URL to which to connect\r\n * @param {Array} protocols The subprotocols\r\n * @param {Object} [options] Connection options\r\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\r\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\r\n *     times in the same tick\r\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n *     automatically send a pong in response to a ping\r\n * @param {Function} [options.finishRequest] A function which can be used to\r\n *     customize the headers of each http request before it is sent\r\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\r\n *     redirects\r\n * @param {Function} [options.generateMask] The function used to generate the\r\n *     masking key\r\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\r\n *     handshake request\r\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n *     size\r\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\r\n *     allowed\r\n * @param {String} [options.origin] Value of the `Origin` or\r\n *     `Sec-WebSocket-Origin` header\r\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\r\n *     permessage-deflate\r\n * @param {Number} [options.protocolVersion=13] Value of the\r\n *     `Sec-WebSocket-Version` header\r\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n *     not to skip UTF-8 validation for text and close messages\r\n * @private\r\n */\r\nfunction initAsClient(websocket, address, protocols, options) {\r\n  const opts = {\r\n    allowSynchronousEvents: true,\r\n    autoPong: true,\r\n    protocolVersion: protocolVersions[1],\r\n    maxPayload: 100 * 1024 * 1024,\r\n    skipUTF8Validation: false,\r\n    perMessageDeflate: true,\r\n    followRedirects: false,\r\n    maxRedirects: 10,\r\n    ...options,\r\n    socketPath: undefined,\r\n    hostname: undefined,\r\n    protocol: undefined,\r\n    timeout: undefined,\r\n    method: 'GET',\r\n    host: undefined,\r\n    path: undefined,\r\n    port: undefined\r\n  };\r\n\r\n  websocket._autoPong = opts.autoPong;\r\n\r\n  if (!protocolVersions.includes(opts.protocolVersion)) {\r\n    throw new RangeError(\r\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\r\n        `(supported versions: ${protocolVersions.join(', ')})`\r\n    );\r\n  }\r\n\r\n  let parsedUrl;\r\n\r\n  if (address instanceof URL) {\r\n    parsedUrl = address;\r\n  } else {\r\n    try {\r\n      parsedUrl = new URL(address);\r\n    } catch (e) {\r\n      throw new SyntaxError(`Invalid URL: ${address}`);\r\n    }\r\n  }\r\n\r\n  if (parsedUrl.protocol === 'http:') {\r\n    parsedUrl.protocol = 'ws:';\r\n  } else if (parsedUrl.protocol === 'https:') {\r\n    parsedUrl.protocol = 'wss:';\r\n  }\r\n\r\n  websocket._url = parsedUrl.href;\r\n\r\n  const isSecure = parsedUrl.protocol === 'wss:';\r\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\r\n  let invalidUrlMessage;\r\n\r\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\r\n    invalidUrlMessage =\r\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\r\n      '\"http:\", \"https\", or \"ws+unix:\"';\r\n  } else if (isIpcUrl && !parsedUrl.pathname) {\r\n    invalidUrlMessage = \"The URL's pathname is empty\";\r\n  } else if (parsedUrl.hash) {\r\n    invalidUrlMessage = 'The URL contains a fragment identifier';\r\n  }\r\n\r\n  if (invalidUrlMessage) {\r\n    const err = new SyntaxError(invalidUrlMessage);\r\n\r\n    if (websocket._redirects === 0) {\r\n      throw err;\r\n    } else {\r\n      emitErrorAndClose(websocket, err);\r\n      return;\r\n    }\r\n  }\r\n\r\n  const defaultPort = isSecure ? 443 : 80;\r\n  const key = randomBytes(16).toString('base64');\r\n  const request = isSecure ? https.request : http.request;\r\n  const protocolSet = new Set();\r\n  let perMessageDeflate;\r\n\r\n  opts.createConnection =\r\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\r\n  opts.defaultPort = opts.defaultPort || defaultPort;\r\n  opts.port = parsedUrl.port || defaultPort;\r\n  opts.host = parsedUrl.hostname.startsWith('[')\r\n    ? parsedUrl.hostname.slice(1, -1)\r\n    : parsedUrl.hostname;\r\n  opts.headers = {\r\n    ...opts.headers,\r\n    'Sec-WebSocket-Version': opts.protocolVersion,\r\n    'Sec-WebSocket-Key': key,\r\n    Connection: 'Upgrade',\r\n    Upgrade: 'websocket'\r\n  };\r\n  opts.path = parsedUrl.pathname + parsedUrl.search;\r\n  opts.timeout = opts.handshakeTimeout;\r\n\r\n  if (opts.perMessageDeflate) {\r\n    perMessageDeflate = new PerMessageDeflate(\r\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\r\n      false,\r\n      opts.maxPayload\r\n    );\r\n    opts.headers['Sec-WebSocket-Extensions'] = format({\r\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\r\n    });\r\n  }\r\n  if (protocols.length) {\r\n    for (const protocol of protocols) {\r\n      if (\r\n        typeof protocol !== 'string' ||\r\n        !subprotocolRegex.test(protocol) ||\r\n        protocolSet.has(protocol)\r\n      ) {\r\n        throw new SyntaxError(\r\n          'An invalid or duplicated subprotocol was specified'\r\n        );\r\n      }\r\n\r\n      protocolSet.add(protocol);\r\n    }\r\n\r\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\r\n  }\r\n  if (opts.origin) {\r\n    if (opts.protocolVersion < 13) {\r\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\r\n    } else {\r\n      opts.headers.Origin = opts.origin;\r\n    }\r\n  }\r\n  if (parsedUrl.username || parsedUrl.password) {\r\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\r\n  }\r\n\r\n  if (isIpcUrl) {\r\n    const parts = opts.path.split(':');\r\n\r\n    opts.socketPath = parts[0];\r\n    opts.path = parts[1];\r\n  }\r\n\r\n  let req;\r\n\r\n  if (opts.followRedirects) {\r\n    if (websocket._redirects === 0) {\r\n      websocket._originalIpc = isIpcUrl;\r\n      websocket._originalSecure = isSecure;\r\n      websocket._originalHostOrSocketPath = isIpcUrl\r\n        ? opts.socketPath\r\n        : parsedUrl.host;\r\n\r\n      const headers = options && options.headers;\r\n\r\n      //\r\n      // Shallow copy the user provided options so that headers can be changed\r\n      // without mutating the original object.\r\n      //\r\n      options = { ...options, headers: {} };\r\n\r\n      if (headers) {\r\n        for (const [key, value] of Object.entries(headers)) {\r\n          options.headers[key.toLowerCase()] = value;\r\n        }\r\n      }\r\n    } else if (websocket.listenerCount('redirect') === 0) {\r\n      const isSameHost = isIpcUrl\r\n        ? websocket._originalIpc\r\n          ? opts.socketPath === websocket._originalHostOrSocketPath\r\n          : false\r\n        : websocket._originalIpc\r\n          ? false\r\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\r\n\r\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\r\n        //\r\n        // Match curl 7.77.0 behavior and drop the following headers. These\r\n        // headers are also dropped when following a redirect to a subdomain.\r\n        //\r\n        delete opts.headers.authorization;\r\n        delete opts.headers.cookie;\r\n\r\n        if (!isSameHost) delete opts.headers.host;\r\n\r\n        opts.auth = undefined;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\r\n    // If the `Authorization` header is set, then there is nothing to do as it\r\n    // will take precedence.\r\n    //\r\n    if (opts.auth && !options.headers.authorization) {\r\n      options.headers.authorization =\r\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\r\n    }\r\n\r\n    req = websocket._req = request(opts);\r\n\r\n    if (websocket._redirects) {\r\n      //\r\n      // Unlike what is done for the `'upgrade'` event, no early exit is\r\n      // triggered here if the user calls `websocket.close()` or\r\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\r\n      // is because the user can also call `request.destroy()` with an error\r\n      // before calling `websocket.close()` or `websocket.terminate()` and this\r\n      // would result in an error being emitted on the `request` object with no\r\n      // `'error'` event listeners attached.\r\n      //\r\n      websocket.emit('redirect', websocket.url, req);\r\n    }\r\n  } else {\r\n    req = websocket._req = request(opts);\r\n  }\r\n\r\n  if (opts.timeout) {\r\n    req.on('timeout', () => {\r\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\r\n    });\r\n  }\r\n\r\n  req.on('error', (err) => {\r\n    if (req === null || req[kAborted]) return;\r\n\r\n    req = websocket._req = null;\r\n    emitErrorAndClose(websocket, err);\r\n  });\r\n\r\n  req.on('response', (res) => {\r\n    const location = res.headers.location;\r\n    const statusCode = res.statusCode;\r\n\r\n    if (\r\n      location &&\r\n      opts.followRedirects &&\r\n      statusCode >= 300 &&\r\n      statusCode < 400\r\n    ) {\r\n      if (++websocket._redirects > opts.maxRedirects) {\r\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\r\n        return;\r\n      }\r\n\r\n      req.abort();\r\n\r\n      let addr;\r\n\r\n      try {\r\n        addr = new URL(location, address);\r\n      } catch (e) {\r\n        const err = new SyntaxError(`Invalid URL: ${location}`);\r\n        emitErrorAndClose(websocket, err);\r\n        return;\r\n      }\r\n\r\n      initAsClient(websocket, addr, protocols, options);\r\n    } else if (!websocket.emit('unexpected-response', req, res)) {\r\n      abortHandshake(\r\n        websocket,\r\n        req,\r\n        `Unexpected server response: ${res.statusCode}`\r\n      );\r\n    }\r\n  });\r\n\r\n  req.on('upgrade', (res, socket, head) => {\r\n    websocket.emit('upgrade', res);\r\n\r\n    //\r\n    // The user may have closed the connection from a listener of the\r\n    // `'upgrade'` event.\r\n    //\r\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\r\n\r\n    req = websocket._req = null;\r\n\r\n    const upgrade = res.headers.upgrade;\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\r\n      return;\r\n    }\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    if (res.headers['sec-websocket-accept'] !== digest) {\r\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\r\n      return;\r\n    }\r\n\r\n    const serverProt = res.headers['sec-websocket-protocol'];\r\n    let protError;\r\n\r\n    if (serverProt !== undefined) {\r\n      if (!protocolSet.size) {\r\n        protError = 'Server sent a subprotocol but none was requested';\r\n      } else if (!protocolSet.has(serverProt)) {\r\n        protError = 'Server sent an invalid subprotocol';\r\n      }\r\n    } else if (protocolSet.size) {\r\n      protError = 'Server sent no subprotocol';\r\n    }\r\n\r\n    if (protError) {\r\n      abortHandshake(websocket, socket, protError);\r\n      return;\r\n    }\r\n\r\n    if (serverProt) websocket._protocol = serverProt;\r\n\r\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\r\n\r\n    if (secWebSocketExtensions !== undefined) {\r\n      if (!perMessageDeflate) {\r\n        const message =\r\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\r\n          'was requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      let extensions;\r\n\r\n      try {\r\n        extensions = parse(secWebSocketExtensions);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      const extensionNames = Object.keys(extensions);\r\n\r\n      if (\r\n        extensionNames.length !== 1 ||\r\n        extensionNames[0] !== PerMessageDeflate.extensionName\r\n      ) {\r\n        const message = 'Server indicated an extension that was not requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      websocket._extensions[PerMessageDeflate.extensionName] =\r\n        perMessageDeflate;\r\n    }\r\n\r\n    websocket.setSocket(socket, head, {\r\n      allowSynchronousEvents: opts.allowSynchronousEvents,\r\n      generateMask: opts.generateMask,\r\n      maxPayload: opts.maxPayload,\r\n      skipUTF8Validation: opts.skipUTF8Validation\r\n    });\r\n  });\r\n\r\n  if (opts.finishRequest) {\r\n    opts.finishRequest(req, websocket);\r\n  } else {\r\n    req.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Emit the `'error'` and `'close'` events.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {Error} The error to emit\r\n * @private\r\n */\r\nfunction emitErrorAndClose(websocket, err) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  //\r\n  // The following assignment is practically useless and is done only for\r\n  // consistency.\r\n  //\r\n  websocket._errorEmitted = true;\r\n  websocket.emit('error', err);\r\n  websocket.emitClose();\r\n}\r\n\r\n/**\r\n * Create a `net.Socket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {net.Socket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction netConnect(options) {\r\n  options.path = options.socketPath;\r\n  return net.connect(options);\r\n}\r\n\r\n/**\r\n * Create a `tls.TLSSocket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {tls.TLSSocket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction tlsConnect(options) {\r\n  options.path = undefined;\r\n\r\n  if (!options.servername && options.servername !== '') {\r\n    options.servername = net.isIP(options.host) ? '' : options.host;\r\n  }\r\n\r\n  return tls.connect(options);\r\n}\r\n\r\n/**\r\n * Abort the handshake and emit an error.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\r\n *     abort or the socket to destroy\r\n * @param {String} message The error message\r\n * @private\r\n */\r\nfunction abortHandshake(websocket, stream, message) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  const err = new Error(message);\r\n  Error.captureStackTrace(err, abortHandshake);\r\n\r\n  if (stream.setHeader) {\r\n    stream[kAborted] = true;\r\n    stream.abort();\r\n\r\n    if (stream.socket && !stream.socket.destroyed) {\r\n      //\r\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\r\n      // called after the request completed. See\r\n      // https://github.com/websockets/ws/issues/1869.\r\n      //\r\n      stream.socket.destroy();\r\n    }\r\n\r\n    process.nextTick(emitErrorAndClose, websocket, err);\r\n  } else {\r\n    stream.destroy(err);\r\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\r\n    stream.once('close', websocket.emitClose.bind(websocket));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\r\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {*} [data] The data to send\r\n * @param {Function} [cb] Callback\r\n * @private\r\n */\r\nfunction sendAfterClose(websocket, data, cb) {\r\n  if (data) {\r\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\r\n\r\n    //\r\n    // The `_bufferedAmount` property is used only when the peer is a client and\r\n    // the opening handshake fails. Under these circumstances, in fact, the\r\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\r\n    // properties are set to `null`.\r\n    //\r\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\r\n    else websocket._bufferedAmount += length;\r\n  }\r\n\r\n  if (cb) {\r\n    const err = new Error(\r\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\r\n        `(${readyStates[websocket.readyState]})`\r\n    );\r\n    process.nextTick(cb, err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'conclude'` event.\r\n *\r\n * @param {Number} code The status code\r\n * @param {Buffer} reason The reason for closing\r\n * @private\r\n */\r\nfunction receiverOnConclude(code, reason) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._closeFrameReceived = true;\r\n  websocket._closeMessage = reason;\r\n  websocket._closeCode = code;\r\n\r\n  if (websocket._socket[kWebSocket] === undefined) return;\r\n\r\n  websocket._socket.removeListener('data', socketOnData);\r\n  process.nextTick(resume, websocket._socket);\r\n\r\n  if (code === 1005) websocket.close();\r\n  else websocket.close(code, reason);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'drain'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnDrain() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (!websocket.isPaused) websocket._socket.resume();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'error'` event.\r\n *\r\n * @param {(RangeError|Error)} err The emitted error\r\n * @private\r\n */\r\nfunction receiverOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._socket[kWebSocket] !== undefined) {\r\n    websocket._socket.removeListener('data', socketOnData);\r\n\r\n    //\r\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\r\n    // https://github.com/websockets/ws/issues/1940.\r\n    //\r\n    process.nextTick(resume, websocket._socket);\r\n\r\n    websocket.close(err[kStatusCode]);\r\n  }\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'finish'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnFinish() {\r\n  this[kWebSocket].emitClose();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'message'` event.\r\n *\r\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\r\n * @param {Boolean} isBinary Specifies whether the message is binary or not\r\n * @private\r\n */\r\nfunction receiverOnMessage(data, isBinary) {\r\n  this[kWebSocket].emit('message', data, isBinary);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'ping'` event.\r\n *\r\n * @param {Buffer} data The data included in the ping frame\r\n * @private\r\n */\r\nfunction receiverOnPing(data) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\r\n  websocket.emit('ping', data);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'pong'` event.\r\n *\r\n * @param {Buffer} data The data included in the pong frame\r\n * @private\r\n */\r\nfunction receiverOnPong(data) {\r\n  this[kWebSocket].emit('pong', data);\r\n}\r\n\r\n/**\r\n * Resume a readable stream\r\n *\r\n * @param {Readable} stream The readable stream\r\n * @private\r\n */\r\nfunction resume(stream) {\r\n  stream.resume();\r\n}\r\n\r\n/**\r\n * The `Sender` error event handler.\r\n *\r\n * @param {Error} The error\r\n * @private\r\n */\r\nfunction senderOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket.readyState === WebSocket.CLOSED) return;\r\n  if (websocket.readyState === WebSocket.OPEN) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    setCloseTimer(websocket);\r\n  }\r\n\r\n  //\r\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\r\n  // peer to finish sending queued data. There is no need to set a timer here\r\n  // because `CLOSING` means that it is already set or not needed.\r\n  //\r\n  this._socket.end();\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Set a timer to destroy the underlying raw socket of a WebSocket.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @private\r\n */\r\nfunction setCloseTimer(websocket) {\r\n  websocket._closeTimer = setTimeout(\r\n    websocket._socket.destroy.bind(websocket._socket),\r\n    closeTimeout\r\n  );\r\n}\r\n\r\n/**\r\n * The listener of the socket `'close'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnClose() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('close', socketOnClose);\r\n  this.removeListener('data', socketOnData);\r\n  this.removeListener('end', socketOnEnd);\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  let chunk;\r\n\r\n  //\r\n  // The close frame might not have been received or the `'end'` event emitted,\r\n  // for example, if the socket was destroyed due to an error. Ensure that the\r\n  // `receiver` stream is closed after writing any remaining buffered data to\r\n  // it. If the readable side of the socket is in flowing mode then there is no\r\n  // buffered data as everything has been already written and `readable.read()`\r\n  // will return `null`. If instead, the socket is paused, any possible buffered\r\n  // data will be read as a single chunk.\r\n  //\r\n  if (\r\n    !this._readableState.endEmitted &&\r\n    !websocket._closeFrameReceived &&\r\n    !websocket._receiver._writableState.errorEmitted &&\r\n    (chunk = websocket._socket.read()) !== null\r\n  ) {\r\n    websocket._receiver.write(chunk);\r\n  }\r\n\r\n  websocket._receiver.end();\r\n\r\n  this[kWebSocket] = undefined;\r\n\r\n  clearTimeout(websocket._closeTimer);\r\n\r\n  if (\r\n    websocket._receiver._writableState.finished ||\r\n    websocket._receiver._writableState.errorEmitted\r\n  ) {\r\n    websocket.emitClose();\r\n  } else {\r\n    websocket._receiver.on('error', receiverOnFinish);\r\n    websocket._receiver.on('finish', receiverOnFinish);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction socketOnData(chunk) {\r\n  if (!this[kWebSocket]._receiver.write(chunk)) {\r\n    this.pause();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnEnd() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  websocket._receiver.end();\r\n  this.end();\r\n}\r\n\r\n/**\r\n * The listener of the socket `'error'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', NOOP);\r\n\r\n  if (websocket) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    this.destroy();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "../node_modules/ws/wrapper.mjs":
/*!**************************************!*\
  !*** ../node_modules/ws/wrapper.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"../node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"../node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"../node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"../node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"../node_modules/ws/lib/websocket-server.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\r\n\n\n//# sourceURL=webpack://backend/../node_modules/ws/wrapper.mjs?");

/***/ })

};
;